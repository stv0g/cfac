package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/url"
	"os"
	"path"
	"strings"
	"time"

	"github.com/stv0g/cfac/pkg/mobility/autobahn"
)

type RoadList []autobahn.Road

func (i *RoadList) String() string {
	strs := []string{}
	for _, road := range *i {
		strs = append(strs, string(road))
	}
	return strings.Join(strs, " ")
}

func (i *RoadList) Set(value string) error {
	value = strings.ToUpper(value)
	*i = append(*i, autobahn.Road(value))
	return nil
}

func getLivestreamWebcams(road autobahn.Road) ([]autobahn.Webcam, error) {

	livestreamWebcams := []autobahn.Webcam{}

	webcams, err := autobahn.GetWebcams(road)
	if err != nil {
		return nil, err
	}

	for _, webcam := range webcams {
		if webcam.LinkURL != "" {
			livestreamWebcams = append(livestreamWebcams, webcam)
		}
	}

	return livestreamWebcams, nil
}

// https://datatracker.ietf.org/doc/html/rfc8216#section-4
func writeM3U8Playlist(w io.Writer, road autobahn.Road, cams []autobahn.Webcam) error {
	for _, cam := range cams {
		stream, err := transformLinkURL(cam.LinkURL)
		if err != nil {
			return err
		}

		camJson, err := json.Marshal(&cam)
		if err != nil {
			return err
		}

		fmt.Fprintln(w)
		fmt.Fprintf(w, "#EXTALB:%s\n", road)
		fmt.Fprintf(w, "#EXTART:%s\n", cam.Operator)
		fmt.Fprintf(w, "#EXTINF:-1,%s | %s | %s\n", cam.Title, cam.Subtitle, cam.Operator)
		fmt.Fprintf(w, "# %s\n", camJson)
		fmt.Fprintln(w, stream)
	}

	return nil
}

// The NRW webcams are delivered by a cluster of Wowza Streaming Engines which are fronted by a cluster of TLS proxies
// We rewrite and simplify the stream URLs to use the streaming server directly
//
// See also: https://www.wowza.com/docs/about-playing-wowza-streaming-engine-streams
//
// Example:
//   Original: https://www.blitzvideoserver.de/player_strassennrw.html?serverip=62.113.210.7&serverapp=strassennrw-rtplive&streamname=10107886632285296527
//      RTSP: rtsp://62.113.210.7/strassennrw-rtplive/10107898794605103925.stream
//      HLS: http://62.113.210.7/strassennrw-rtplive/10107898794605103925.stream/playlist.m3u8
func transformLinkURL(u string) (string, error) {
	m, err := url.Parse(u)
	if err != nil {
		return "", err
	}

	if m.Host == "www.blitzvideoserver.de" {
		serverIP := m.Query()["serverip"][0]
		serverApp := m.Query()["serverapp"][0]
		streamName := m.Query()["streamname"][0]

		l := url.URL{
			Scheme: "http",
			Host:   serverIP,
			Path:   path.Join(serverApp, streamName+".stream", "playlist.m3u8"),
		}

		return l.String(), nil
	} else {
		return u, nil
	}
}

func main() {
	var selectedRoads RoadList

	flag.Var(&selectedRoads, "roads", "list of roads for which we should find webcams")
	flag.Parse()

	if len(selectedRoads) == 0 {
		allRoads, err := autobahn.GetRoads()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get roads: %s", err)
			os.Exit(-1)
		}

		selectedRoads = RoadList(allRoads)
	}

	w := os.Stdout

	fmt.Fprintf(w, "# Generated by cfac (https://github.com/stv0g/cfac) on %s\n", time.Now())
	fmt.Fprintln(w, "#EXTM3U")
	fmt.Fprintln(w, "#PLAYLIST: Autobahn Livestreams")

	camCount := 0

	for _, road := range selectedRoads {
		// The API is broken for road A1/A59 as its the only roadname with a slash
		if strings.Contains(string(road), "/") {
			continue
		}

		cams, err := getLivestreamWebcams(road)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get webcams for road %s: %s", road, err)
			continue
		}

		if err = writeM3U8Playlist(w, road, cams); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get roads: %s", err)
			continue
		}

		camCount += len(cams)
	}

	fmt.Fprintln(w)
	fmt.Fprintf(w, "# Total cam count: %d\n", camCount)
}
